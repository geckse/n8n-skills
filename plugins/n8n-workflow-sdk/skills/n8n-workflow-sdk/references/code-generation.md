# Code Generation Reference

Complete reference for converting between JSON and code, the generation pipeline, and parsing in the `@n8n/workflow-sdk`.

## Table of Contents

- [Overview](#overview)
- [JSON to Code: `generateWorkflowCode()`](#json-to-code-generateworkflowcode)
- [Code to JSON: `parseWorkflowCode()`](#code-to-json-parseworkflowcode)
- [Code to Builder: `parseWorkflowCodeToBuilder()`](#code-to-builder-parseworkflowcodetobuilder)
- [Code Generation Pipeline](#code-generation-pipeline)
- [Semantic Registry](#semantic-registry)
- [Round-Trip Examples](#round-trip-examples)
- [Utility Functions](#utility-functions)

## Overview

The SDK provides bidirectional conversion between n8n workflow JSON and TypeScript SDK code:

- **JSON → Code**: `generateWorkflowCode()` — Produces human-readable TypeScript that uses the SDK builder API
- **Code → JSON**: `parseWorkflowCode()` — Parses SDK code back into n8n workflow JSON
- **Code → Builder**: `parseWorkflowCodeToBuilder()` — Parses into a WorkflowBuilder (supports validation before JSON export)

## JSON to Code: `generateWorkflowCode()`

### Simple Usage

```typescript
import { generateWorkflowCode } from '@n8n/workflow-sdk'

const code = generateWorkflowCode(workflowJSON)
// Returns: TypeScript string using SDK builder API
```

### With Execution Context

```typescript
const code = generateWorkflowCode({
  workflow: workflowJSON,
  executionSchema: nodeExecutionSchemas,
  expressionValues: expressionValueMap,
  executionData: runExecutionData,
  valuesExcluded: false,
  pinnedNodes: ['HTTP Request', 'Set']
})
```

**GenerateWorkflowCodeOptions:**

| Property | Type | Description |
|----------|------|-------------|
| `workflow` | `WorkflowJSON` | The workflow JSON to convert (required) |
| `executionSchema` | `NodeExecutionSchema[]` | Execution schemas with output types |
| `expressionValues` | `Record<string, ExpressionValue[]>` | Resolved expression values from frontend |
| `executionData` | `IRunExecutionData['resultData']` | Execution result data |
| `valuesExcluded` | `boolean` | Whether expression values were excluded |
| `pinnedNodes` | `string[]` | Node names with pinned data |

### Generated Code Format

The output is a complete TypeScript module:

```typescript
// Generated by @n8n/workflow-sdk
import {
  workflow, node, trigger, merge, ifElse, switchCase,
  languageModel, tool, memory, fromAi,
  expr, serializeExpression
} from '@n8n/workflow-sdk'

const manualTrigger = trigger({
  type: 'n8n-nodes-base.manualTrigger',
  version: 1,
  config: { name: 'When clicking "Test workflow"' }
})

const httpRequest = node({
  type: 'n8n-nodes-base.httpRequest',
  version: 4.4,
  config: {
    name: 'HTTP Request',
    parameters: {
      url: 'https://api.example.com/data',
      method: 'GET'
    },
    output: [{ json: { id: 1, name: 'Example' } }]
  }
})

const wf = workflow('workflow-id', 'My Workflow')
  .add(manualTrigger)
  .to(httpRequest)
  .generatePinData()

export default wf
```

### What the Generator Handles

1. **Node declarations** — Each node becomes a `node()` or `trigger()` call
2. **Connections** — Sequential chains use `.to()`, branching uses `.onTrue()`/`.onCase()`
3. **Composite nodes** — IF/Else, Switch, Merge, SplitInBatches use their builder APIs
4. **Subnodes** — AI subnodes are declared separately and attached via `subnodes` config
5. **Expressions** — Converted to `expr()` or `serializeExpression()` calls
6. **Pin data** — Converted to `output` declarations + `generatePinData()`
7. **Settings** — Workflow settings preserved
8. **Cycle detection** — Loops (SplitInBatches) properly handled with `nextBatch()`

## Code to JSON: `parseWorkflowCode()`

Parses SDK code (TypeScript/JavaScript) back into n8n workflow JSON.

```typescript
import { parseWorkflowCode } from '@n8n/workflow-sdk'

const json = parseWorkflowCode(codeString)
// Returns: WorkflowJSON
```

The parser uses a **secure AST interpreter** — it does NOT use `eval()`. It safely interprets the SDK builder calls and reconstructs the workflow graph.

### Supported Constructs

The parser handles all standard SDK patterns:

```typescript
// These all parse correctly:
workflow('id', 'name')
workflow.fromJSON(json)
node({ type: '...', version: 1, config: { ... } })
trigger({ type: '...', version: 1, config: { ... } })
languageModel({ ... })
tool({ ... })
memory({ ... })
// ... all subnode factories
.add(node)
.to(node)
.to([node1, node2])
.connect(src, 0, tgt, 0)
.settings({ ... })
.generatePinData()
node.onTrue(target)
node.onFalse(target)
node.onCase(index, target)
node.onError(handler)
node.input(index)
node.output(index)
merge({ ... })
splitInBatches({ ... })
nextBatch(sib)
sib.onEachBatch(target)
sib.onDone(target)
ifElse({ ... })
switchCase({ ... })
expr('...')
serializeExpression($ => ...)
fromAi('key', ...)
placeholder('...')
newCredential('...')
sticky('...')
```

## Code to Builder: `parseWorkflowCodeToBuilder()`

Like `parseWorkflowCode()` but returns a `WorkflowBuilder` instead of JSON. This is useful when you want to validate before exporting.

```typescript
import { parseWorkflowCodeToBuilder, validateWorkflow } from '@n8n/workflow-sdk'

const builder = parseWorkflowCodeToBuilder(codeString)

// Validate first
const result = validateWorkflow(builder)
if (!result.valid) {
  throw new Error(`Invalid: ${result.errors.map(e => e.message).join(', ')}`)
}

// Then export
const json = builder.toJSON()
```

## Code Generation Pipeline

The code generation process has four phases:

### Phase 1: Build Semantic Graph

```typescript
import { buildSemanticGraph } from '@n8n/workflow-sdk'

const graph = buildSemanticGraph(workflowJSON)
```

Converts index-based connections to semantic names. For example, IF node output 0 becomes "true" and output 1 becomes "false".

### Phase 2: Annotate Graph

```typescript
import { annotateGraph } from '@n8n/workflow-sdk'

annotateGraph(graph)
```

Detects:
- **Cycles** — Loop-back connections (SplitInBatches)
- **Convergence points** — Where branches merge back together

### Phase 3: Build Composite Tree

```typescript
import { buildCompositeTree } from '@n8n/workflow-sdk'

const tree = buildCompositeTree(graph)
```

Groups nodes into composite structures:
- IF + branches → IfElse composite
- Switch + cases → SwitchCase composite
- SplitInBatches + loop → SIB composite
- Merge + inputs → Merge composite

### Phase 4: Generate Code

```typescript
import { generateCode } from '@n8n/workflow-sdk'

const code = generateCode(tree, workflowJSON, graph, options)
```

Emits TypeScript code using the SDK builder API.

### Running the Full Pipeline

`generateWorkflowCode()` runs all four phases automatically. You only need to use the individual functions if you need to inspect or modify the intermediate representations.

## Semantic Registry

### getOutputName()

```typescript
import { getOutputName } from '@n8n/workflow-sdk'

getOutputName('n8n-nodes-base.if', 0, ifNodeJSON)       // 'true'
getOutputName('n8n-nodes-base.if', 1, ifNodeJSON)       // 'false'
getOutputName('n8n-nodes-base.switch', 0, switchJSON)    // 'case0'
getOutputName('n8n-nodes-base.switch', 1, switchJSON)    // 'case1'
getOutputName('n8n-nodes-base.splitInBatches', 0, sibJSON) // 'done'
getOutputName('n8n-nodes-base.splitInBatches', 1, sibJSON) // 'eachBatch'
```

### getInputName()

```typescript
import { getInputName } from '@n8n/workflow-sdk'

getInputName('n8n-nodes-base.merge', 0, mergeJSON)  // 'input1'
getInputName('n8n-nodes-base.merge', 1, mergeJSON)  // 'input2'
```

### getCompositeType()

```typescript
import { getCompositeType } from '@n8n/workflow-sdk'

getCompositeType('n8n-nodes-base.if')              // 'ifElse'
getCompositeType('n8n-nodes-base.switch')           // 'switchCase'
getCompositeType('n8n-nodes-base.merge')            // 'merge'
getCompositeType('n8n-nodes-base.splitInBatches')   // 'splitInBatches'
getCompositeType('n8n-nodes-base.httpRequest')       // undefined
```

### getNodeSemantics()

```typescript
import { getNodeSemantics } from '@n8n/workflow-sdk'

const semantics = getNodeSemantics('n8n-nodes-base.if', 2)
// Returns: NodeSemantics with output names, input names, composite type, etc.
```

### isCycleOutput()

```typescript
import { isCycleOutput } from '@n8n/workflow-sdk'

isCycleOutput('n8n-nodes-base.splitInBatches', 'eachBatch')  // true (loop-back)
isCycleOutput('n8n-nodes-base.splitInBatches', 'done')        // false
isCycleOutput('n8n-nodes-base.if', 'true')                     // false
```

## Round-Trip Examples

### Simple Workflow Round-Trip

```typescript
import { workflow, node, trigger, generateWorkflowCode, parseWorkflowCode } from '@n8n/workflow-sdk'

// 1. Build workflow
const wf = workflow('test', 'Round Trip Test')
  .add(trigger({ type: 'n8n-nodes-base.manualTrigger', version: 1, config: {} }))
  .to(node({
    type: 'n8n-nodes-base.httpRequest', version: 4.4,
    config: { name: 'Fetch', parameters: { url: 'https://api.example.com' } }
  }))

// 2. Export to JSON
const json1 = wf.toJSON()

// 3. Generate code from JSON
const code = generateWorkflowCode(json1)

// 4. Parse code back to JSON
const json2 = parseWorkflowCode(code)

// 5. Verify: both JSONs should have same structure
// json1.nodes.length === json2.nodes.length
// json1.connections keys match json2.connections keys
```

### Complex Workflow Round-Trip

```typescript
// Build a complex workflow with IF, Merge, and AI nodes
const wf = workflow('complex', 'Complex Round Trip')
  .add(trigger({ type: 'n8n-nodes-base.webhook', version: 2.1, config: {
    parameters: { path: 'test', httpMethod: 'POST' }
  }}))
  .to(ifNode.onTrue(
    node({ type: 'n8n-nodes-base.httpRequest', version: 4.4, config: { name: 'True Path' } })
  ).onFalse(
    node({ type: 'n8n-nodes-base.set', version: 3.4, config: { name: 'False Path' } })
  ))
  .to(mergeNode)
  .to(respondNode)

// Round-trip
const json = wf.toJSON()
const code = generateWorkflowCode(json)
const roundTripped = parseWorkflowCode(code)

// Validate both
const result1 = validateWorkflow(json)
const result2 = validateWorkflow(roundTripped)
// Both should be valid
```

### Modify During Round-Trip

```typescript
// Start with existing JSON
const originalJSON = { /* ... */ }

// Convert to code for understanding
const code = generateWorkflowCode(originalJSON)
console.log(code)  // Read and understand the workflow

// Parse into builder for modification
const builder = parseWorkflowCodeToBuilder(code)

// Validate
const result = validateWorkflow(builder)

// Export modified version
const modifiedJSON = builder.toJSON()
```

## Utility Functions

### Utility Type Guards

```typescript
import { isNodeChain, isNodeInstance } from '@n8n/workflow-sdk'

isNodeChain(value)     // Check if value is a NodeChain
isNodeInstance(value)   // Check if value is a NodeInstance
```

### Utility Helpers

```typescript
import { isPlainObject, getProperty, hasProperty } from '@n8n/workflow-sdk'

isPlainObject({ a: 1 })          // true
isPlainObject([1, 2])            // false
isPlainObject(null)               // false

getProperty({ a: { b: 3 } }, 'a.b')  // 3
getProperty({}, 'missing')            // undefined

hasProperty({ a: 1 }, 'a')       // true
hasProperty({ a: 1 }, 'b')       // false
```
